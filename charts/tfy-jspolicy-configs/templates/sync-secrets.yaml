{{- if .Values.syncSecrets.enabled -}}
apiVersion: policy.jspolicy.com/v1beta1
kind: JsPolicy
metadata:
  name: "{{ .Release.Name }}-sync-secrets.truefoundry.com"
spec:
  operations: ["CREATE"]
  resources: ["secrets"]
  dependencies:
    "js-yaml": "^4.1.0"
  type: Controller
  javascript: |
    // this policy will sync changes to a secret to all other secrets in the cluster
    // that have labels in syncSecrets.labelSelector
    import { load } from 'js-yaml';

    function parseYamlString(yamlString) {
      try {
        return load(yamlString);
      } catch (e) {
        console.log("Error parsing YAML string:", e);
        return null;
      }
    }

    const excludedNamespaces = parseYamlString(`{{ .Values.syncSecrets.excludeNamespaces | toYaml | nindent 4 }}`);
    let includedNamespaces = undefined;
    if (parseYamlString(`{{ .Values.syncSecrets.includeNamespaces | toYaml | nindent 4 }}`) === "*") {
      includedNamespaces = list("Namespace", "v1").map(namespace => namespace.metadata.name);
    } else {
      includedNamespaces = parseYamlString(`{{ .Values.syncSecrets.includeNamespaces | toYaml | nindent 4 }}`);
    }
    const secretNames = parseYamlString(`{{ .Values.syncSecrets.secretNames | toYaml | nindent 4 }}`);

    if (includedNamespaces.length < 0 || secretNames.length < 0) {
      exit();
    } 

    // sync a secret to all namespaces in includedNamespaces
    function syncSecretToAllIncludedNamespaces(parentSecretObject) {
      includedNamespaces.forEach(namespace => {
        if (excludedNamespaces.includes(namespace)){
          return;
        }

        // skip if the current namespace is the same as the parentSecret's namespace
        if (parentSecretObject.metadata.namespace === namespace) {
          return;
        }
        print("Syncing secret " + parentSecretObject.metadata.name + " to namespace: " + namespace);
        const secret = get("Secret", "v1", namespace + "/" + parentSecretObject.metadata.name);
        if (secret === undefined) {
          print("Secret not found, creating secret " + parentSecretObject.metadata.name + " in namespace: " + namespace);
          print("Parent secret data: " + parentSecretObject.data);
          print("Parent secret type: " + parentSecretObject.type);
          print("Parent secret labels: " + parentSecretObject.metadata.labels);
          print("Parent secret annotations: " + parentSecretObject.metadata.annotations);
          print("Parent secret Data: " + parentSecretObject.data);
          secret = create("Secret", "v1", {
            metadata: {
              name: parentSecretObject.metadata.name,
              namespace: namespace,
              labels: parentSecretObject.metadata.labels,
              annotations: parentSecretObject.metadata.annotations
            },
            data: parentSecretObject.data,
            type: parentSecretObject.type
          });
        } else if (secret.data === parentSecretObject.data) {
          print("Secret " + parentSecretObject.metadata.name + " already exists in the namespace " + namespace + " and is the same, skipping");
          return;
        } else {
          print("Secret " + parentSecretObject.metadata.name + " already exists in the namespace " + namespace + " and is different, updating");
          secret.data = parentSecretObject.data;
          const updateResult = update(secret);
          if (!updateResult.ok) {
            // just requeue if we encounter an error
            requeue(updateResult.message);
          } else {
            print(`Successfully synced secret ${secret.metadata.namespace}/${secret.metadata.name}`);
          }
          return;
        }        
      })
    }


    secretNames.forEach(secretName => {
      let parentSecret = get("Secret", "v1", secretName);
      syncSecretToAllIncludedNamespaces(parentSecret);
    });
{{- end -}}