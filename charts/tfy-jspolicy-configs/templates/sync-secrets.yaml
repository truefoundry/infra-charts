{{- if .Values.syncSecrets.enabled -}}
apiVersion: policy.jspolicy.com/v1beta1
kind: JsPolicy
metadata:
  name: "{{ .Release.Name }}-sync-secrets.truefoundry.com"
  labels:
    {{- include "tfy-jspolicy-configs.labels" . | nindent 4 }}
  annotations:
    {{- include "tfy-jspolicy-configs.annotations" . | nindent 4 }}
spec:
  operations: ["CREATE"]
  resources: ["secrets"]
  dependencies:
    "js-yaml": "^4.1.0"
  type: Controller
  javascript: |
    // this policy will sync changes to a secret to all other secrets in the cluster
    // that have labels in syncSecrets.labelSelector
    import { load } from 'js-yaml';

    function parseYamlString(yamlString) {
      try {
        return load(yamlString);
      } catch (e) {
        console.log("Error parsing YAML string:", e);
        return null;
      }
    }

    // get all namespaces in the cluster
    const allNamespaces = list("Namespace", "v1").map(namespace => namespace.metadata.name);
    
    // get the namespaces from the input namespaces. If inputNamespace is a string, return the string. If inputNamespace is an array, return the array. If inputNamespace is a regex, return the namespaces that match the regex. Only basic regex is supported.
    function getNamespaces(inputNamespace) {
      let namespaceList = [];
      let filteredNamespaces = [];
      for (let i in inputNamespace) {
        if (inputNamespace[i] === "*") {
          namespaceList = allNamespaces;
          break;
        }
        if (inputNamespace[i].includes("*")) {
          const regex = new RegExp(inputNamespace[i]);
          filteredNamespaces = allNamespaces.filter(namespace => regex.test(namespace));
          namespaceList = [...namespaceList, ...filteredNamespaces];
        } else {
          namespaceList.push(inputNamespace[i]);
        }
      }
      return namespaceList;
    }

    const inputExcludedNamespaces = parseYamlString(`{{ .Values.syncSecrets.excludeNamespaces | toYaml | nindent 4 }}`);
    const inputInlcudedNamespaces = parseYamlString(`{{ .Values.syncSecrets.includeNamespaces | toYaml | nindent 4 }}`);
    const includedNamespaces = getNamespaces(inputInlcudedNamespaces);
    const excludedNamespaces = getNamespaces(inputExcludedNamespaces);
    print("includedNamespaces", includedNamespaces);
    print("excludedNamespaces", excludedNamespaces);
    const secretNames = parseYamlString(`{{ .Values.syncSecrets.secretNames | toYaml | nindent 4 }}`);
    if ((includedNamespaces.length > 0 && !includedNamespaces.includes(request.namespace)) || excludedNamespaces.includes(request.namespace) || secretNames.length < 0) {
      exit();
    }
    // sync a secret to all namespaces in includedNamespaces
    function syncSecretToAllIncludedNamespaces(parentSecretObject) {
      includedNamespaces.forEach(namespace => {
        if (!allNamespaces.includes(namespace)) {
          print("Skipping creating secret " + parentSecretObject.metadata.name + " in namespace " + namespace + " as it doesn't exists ...");
          return;
        }

        if (excludedNamespaces.includes(namespace)){
          return;
        }

        // skip if the current namespace is the same as the parentSecret's namespace
        if (parentSecretObject.metadata.namespace === namespace) {
          return;
        }
        print("Syncing secret " + parentSecretObject.metadata.name + " to namespace: " + namespace);
        let secret = get("Secret", "v1", namespace + "/" + parentSecretObject.metadata.name);
        if (secret === undefined) {
          print("Secret not found, creating secret " + parentSecretObject.metadata.name + " in namespace: " + namespace);
          secret = create({
            "kind": "Secret",
            "apiVersion": "v1",
            "metadata": {
              "name": parentSecretObject.metadata.name,
              "namespace": namespace
            },
            "data": parentSecretObject.data,
            "type": parentSecretObject.type
          });
          print("Successfully created secret " + secret.metadata.namespace + "/" + secret.metadata.name);
        } else if (JSON.stringify(secret.data) === JSON.stringify(parentSecretObject.data)) {
          print("Secret " + parentSecretObject.metadata.name + " already exists in the namespace " + namespace + " and is the same, skipping");
        } else {
          print("Secret " + parentSecretObject.metadata.name + " already exists in the namespace " + namespace + " and is different, updating");
          secret.data = parentSecretObject.data;
          const updateResult = update(secret);
          if (!updateResult.ok) {
            // just requeue if we encounter an error
            requeue(updateResult.message);
          } else {
            print(`Successfully synced secret ${secret.metadata.namespace}/${secret.metadata.name}`);
          }
        }
        return;       
      })
    }


    secretNames.forEach(secretName => {
      let parentSecret = get("Secret", "v1", secretName);
      if (!parentSecret) {
        print("secret '" + secretName + "'' is not found");
        exit();
      }
      syncSecretToAllIncludedNamespaces(parentSecret);
    });
{{- end -}}