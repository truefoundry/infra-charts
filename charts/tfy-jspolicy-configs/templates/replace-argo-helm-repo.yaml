{{- if .Values.replaceArgoHelmRepo.enabled -}}
apiVersion: policy.jspolicy.com/v1beta1
kind: JsPolicy
metadata:
  name: {{ .Release.Name }}-replace-argo-helm-repo.truefoundry.com
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "tfy-jspolicy-configs.labels" . | nindent 4 }}
  annotations:
    {{- include "tfy-jspolicy-configs.annotations" . | nindent 4 }}
spec:
  type: Mutating
  operations: ["CREATE", "UPDATE"]
  resources: ["applications"]
  apiGroups: ["argoproj.io"]
  apiVersions: ["v1alpha1"]
  failurePolicy: Ignore
  dependencies:
    "js-yaml": "^4.1.0"
  javascript: |
    import { load } from 'js-yaml';

    function parseYamlString(yamlString) {
      try {
        return load(yamlString);
      } catch (e) {
        console.log("Error parsing YAML string:", e);
        return null;
      }
    }

    // get the namespaces from the input namespaces. If inputNamespace is a string, return the string. If inputNamespace is an array, return the array. If inputNamespace is a regex, return the namespaces that match the regex. Only basic regex is supported.
    function getNamespaces(inputNamespace) {
      let namespaceList = [];
      let filteredNamespaces = [];
      const allNamespaces = list("Namespace", "v1").map(namespace => namespace.metadata.name);
      for (let i in inputNamespace) {
        if (inputNamespace[i] === "*") {
          namespaceList = allNamespaces;
          break;
        }
        if (inputNamespace[i].includes("*")) {
          const regex = new RegExp(inputNamespace[i]);
          filteredNamespaces = allNamespaces.filter(namespace => regex.test(namespace));
          namespaceList = [...namespaceList, ...filteredNamespaces];
        } else {
          namespaceList.push(inputNamespace[i]);
        }
      }
      return namespaceList;
    }

    const inputExcludedNamespaces = parseYamlString(`{{ .Values.replaceArgoHelmRepo.excludeNamespaces | toYaml | nindent 4 }}`)
    const inputInlcudedNamespaces = parseYamlString(`{{ .Values.replaceArgoHelmRepo.includeNamespaces | toYaml | nindent 4 }}`)
    const includedNamespaces = getNamespaces(inputInlcudedNamespaces);
    const excludedNamespaces = getNamespaces(inputExcludedNamespaces);
    print("includedNamespaces", includedNamespaces);
    print("excludedNamespaces", excludedNamespaces);
    const registryReplacementMap = parseYamlString(`{{ .Values.replaceArgoHelmRepo.registryReplacementMap | toYaml | nindent 4 }}`)
    if ((includedNamespaces.length > 0 && !includedNamespaces.includes(request.namespace)) || excludedNamespaces.includes(request.namespace) || !registryReplacementMap) {
      exit()
    }

    function getNewRegistry(protocol, hostname) {
      const completeHostname = protocol + '//' + hostname;
      let newRegistry = registryReplacementMap[completeHostname] || registryReplacementMap['*'] || null;
      if (!newRegistry) {
        return
      }
      return newRegistry;
    }

    if (!request.object.spec.source.helm) {
      exit()
    }
    const repoURLString = request.object.spec.source.repoURL;
    let normalizedRepoURL = repoURLString;
    if (!repoURLString.match(/^[a-zA-Z][a-zA-Z\d+\-.]*:/)) {
      normalizedRepoURL = "oci://" + repoURLString;
    }
    const urlParts = normalizedRepoURL.split('/');
    const protocol = urlParts[0];
    const hostname = urlParts[2];

    let newRegistry = getNewRegistry(protocol, hostname);
    if (!newRegistry) {
      exit()
    }
    // oci registry url should not have protocol
    if (newRegistry.startsWith('oci://')) {
      newRegistry = newRegistry.replace('oci://', '');
    }
    if (repoURLString.startsWith(newRegistry)) {
      console.log('Repo URL already has the new registry');
      exit()
    }

    let newRepoURL = normalizedRepoURL.replace(`${protocol}//${hostname}`, newRegistry);
    // remove trailing slash since argo tries to resolve the final url with double slashes
    if (newRepoURL.endsWith('/')) {
      newRepoURL = newRepoURL.slice(0, -1);
    }
    request.object.spec.source.repoURL = newRepoURL;
    mutate(request.object);
{{- end -}}